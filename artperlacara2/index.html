<!DOCTYPE html>
<html lang="ca">
<!--
  Aquesta pàgina mostra una animació interactiva basada en "Gato y Pájaro" de Paul Klee (referència: imatge 1),
  on el rostre del gat reacciona expressivament segons l'emoció detectada a la càmera (somriure, tristesa, sorpresa, ira, fàstic, por, etc.).
  S'utilitza p5.js i ml5.js per a la detecció facial.
-->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gat Expressiu Klee - Art Facial Responsiu</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.3/p5.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/ml5js/Intro-ML-Arts-IMA@ml5-build-10-7-19/ml5_build/ml5.min.js"></script>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background: #222; }
    #loading-screen {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255,255,255,0.95);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      font-family: Arial, sans-serif; z-index: 1000;
    }
    .loader {
      width: 40px; height: 40px;
      border: 5px solid #3498db; border-top-color: transparent;
      border-radius: 50%; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #loading-screen p { margin-top: 15px; font-size: 1.1em; color: #333; }
  </style>
</head>
<body>
<!--
  // Paul Klee: "Gato y Pájaro", animat expressivament segons l'emoció detectada.
  // Els ulls, boca i bigotis del gat canvien subtilment segons somrius, t'enfades, etc.
  // El quadrat i la composició segueixen el llenguatge geomètric original de l'obra.
-->
  <div id="loading-screen">
    <div class="loader"></div>
    <p>Carregant models...</p>
  </div>
  <script>
    // Variables globals per gestió facial i visual
    let faceapi, detections = [], video;
    let modelsReady = false;
    let currentExpression = { dominant: 'neutral', intensity: 0 };
    let smoothIntensity = 0;

    let currentGradientStart, currentGradientEnd;
    let targetGradientStart, targetGradientEnd;

    // Paleta inspirada en l'obra de Klee
    const PALETTE = {
      base: [230,200,130], // fons cremós
      orange: [216, 131, 40],
      ochre: [210, 140, 55],
      red:   [222, 47, 57],
      rose:  [241, 125, 157],
      light: [252, 227, 181],
      shadow: [110, 60, 30],
      eyeWhite: [250, 245, 220],
      eyeGreen: [53, 128, 96],
      nose: [220, 73, 80],
      whisker: [100, 80, 70]
    };

    // Gradient de fons segons emoció
    function getGradientForEmotion(emotion) {
      switch (emotion) {
        case 'happy':
          return { start: color(252,227,181), end: color(255, 183, 77) };
        case 'sad':
          return { start: color(173, 216, 230), end: color(130, 142, 186) };
        case 'angry':
          return { start: color(255, 160, 122), end: color(180, 60, 30) };
        case 'disgusted':
          return { start: color(189, 210, 156), end: color(153, 180, 90) };
        case 'surprised':
          return { start: color(255, 240, 210), end: color(205, 155, 205) };
        case 'fearful':
          return { start: color(240, 225, 200), end: color(100, 100, 150) };
        default:
          return { start: color(230,200,130), end: color(210,140,55) };
      }
    }

    function setGradient(x, y, w, h, c1, c2, axis = 'y') {
      noFill();
      if (axis === 'y') {
        for (let i = y; i <= y + h; i++) {
          let inter = map(i, y, y + h, 0, 1);
          let c = lerpColor(c1, c2, inter);
          stroke(c);
          line(x, i, x + w, i);
        }
      } else if (axis === 'x') {
        for (let i = x; i <= x + w; i++) {
          let inter = map(i, x, x + w, 0, 1);
          let c = lerpColor(c1, c2, inter);
          stroke(c);
          line(i, y, i, y + h);
        }
      }
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      let neutralGrad = getGradientForEmotion('neutral');
      currentGradientStart = neutralGrad.start;
      currentGradientEnd = neutralGrad.end;

      video = createCapture(VIDEO);
      video.size(320, 240);
      video.hide();
      video.elt.muted = true;
      video.elt.playsinline = true;

      const options = {
        withLandmarks: true,
        withExpressions: true,
        withDescriptors: false
      };

      faceapi = ml5.faceApi(video, options, () => {
        modelsReady = true;
        document.getElementById('loading-screen').style.display = 'none';
        faceapi.detect(gotResults);
      });
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      video.size(max(160, width / 4), max(120, height / 4));
    }

    function gotResults(err, results) {
      if (err) {
        console.error(err);
        document.getElementById('loading-screen').innerHTML =
          '<p style="color: red">Error! Comprova la càmera i actualitza.</p>';
        return;
      }
      detections = results;
      if (detections.length > 0) updateCurrentExpression();
      faceapi.detect(gotResults);
    }

    function updateCurrentExpression() {
      let maxIntensity = 0;
      detections.forEach(face => {
        const expr = face.expressions;
        const dominant = Object.keys(expr).reduce((a, b) => expr[a] > expr[b] ? a : b);
        if (expr[dominant] > maxIntensity) {
          currentExpression = {
            dominant: dominant,
            intensity: expr[dominant]
          };
          maxIntensity = expr[dominant];
        }
      });
      let grad = getGradientForEmotion(currentExpression.dominant);
      targetGradientStart = grad.start;
      targetGradientEnd = grad.end;
    }

    function scaleFactor() {
      return Math.min(width, height) / 800;
    }

    function draw() {
      smoothIntensity = lerp(smoothIntensity, currentExpression.intensity, 0.1);
      if (targetGradientStart && targetGradientEnd) {
        currentGradientStart = lerpColor(currentGradientStart, targetGradientStart, 0.1);
        currentGradientEnd = lerpColor(currentGradientEnd, targetGradientEnd, 0.1);
      }
      setGradient(0, 0, width, height, currentGradientStart, currentGradientEnd, 'y');
      push();
      translate(width / 2, height / 2);
      scale(scaleFactor());
      drawKleeCatFace(currentExpression.dominant, smoothIntensity);
      pop();
      drawHUD();
      drawVideoPreview();
    }

    // Dibuixa el rostre del gat segons Klee, animant expressivament
    function drawKleeCatFace(expr, inten) {
      let s = 650;
      let eyeW = 210, eyeH = 75;
      let eyeY = -80;
      let eyeOpen = 1.0, eyeTilt = 0;
      let mouthUp = 0, mouthDown = 0, mouthSmile = 0, mouthFrown = 0, mouthWide = 0;
      let noseY = 90, noseH = 58;
      let whiskerSpread = 1.0;
      let birdColor = PALETTE.rose;

      // Modifica segons emoció
      if(expr === 'happy') {
        eyeOpen = 1.14 + 0.16*inten;
        mouthSmile = 1*inten;
        mouthUp = 10*inten;
        whiskerSpread = 1.13 + 0.10*inten;
        birdColor = [255, 100, 180];
      } else if(expr === 'sad') {
        eyeOpen = 0.82 - 0.22*inten;
        mouthFrown = 1*inten;
        mouthDown = 18*inten;
        whiskerSpread = 0.95 - 0.10*inten;
        noseY += 10*inten;
        birdColor = [190, 170, 230];
      } else if(expr === 'angry') {
        eyeTilt = -0.18*PI*inten;
        eyeOpen = 0.96 - 0.08*inten;
        mouthDown = 5*inten;
        whiskerSpread = 1.05 + 0.10*inten;
        birdColor = [200, 60, 60];
      } else if(expr === 'disgusted') {
        eyeTilt = 0.09*PI*inten;
        eyeOpen = 0.87 - 0.12*inten;
        mouthFrown = 0.4*inten;
        mouthSmile = 0.2*inten;
        whiskerSpread = 1.05;
        birdColor = [120, 200, 130];
      } else if(expr === 'surprised') {
        eyeOpen = 1.5 + 0.33*inten;
        mouthWide = 1*inten;
        mouthUp = 12*inten;
        whiskerSpread = 1.18 + 0.09*inten;
        birdColor = [255, 180, 230];
      } else if(expr === 'fearful') {
        eyeOpen = 1.33 + 0.22*inten;
        mouthWide = 0.8*inten;
        mouthDown = 18*inten;
        whiskerSpread = 1.03 - 0.04*inten;
        birdColor = [210, 210, 250];
      } else { // neutral
        eyeOpen = 1.06;
        whiskerSpread = 1.09;
      }

      // FONS GAT
      noStroke();
      fill(...PALETTE.base, 240);
      rectMode(CENTER);
      rect(0,0,s,s,68);

      // Ombres taronja (simples)
      fill(...PALETTE.orange,43); rect(-s/4,0,s/2, s*0.7, 60);
      fill(...PALETTE.ochre,34); rect(s/4,s/6,s*0.38, s*0.43, 30);

      // ULLS (geomètrics, animats)
      push();
      for(let i=-1;i<=1;i+=2) {
        push();
        translate(i*180, eyeY);
        rotate(i*eyeTilt);
        fill(...PALETTE.eyeWhite);
        stroke(80,60,40,60); strokeWeight(3);
        beginShape();
        for(let a=PI*0.18;a<PI*0.82;a+=0.05){
          let ex = cos(a)*eyeW/2, ey = sin(a)*eyeH/2*eyeOpen;
          vertex(ex,ey);
        }
        for(let a=PI*0.82;a>PI*0.18;a-=0.05){
          let ex = cos(a)*eyeW/2, ey = -sin(a)*eyeH/2*eyeOpen;
          vertex(ex,ey);
        }
        endShape(CLOSE);

        // PUPILA VERTICAL
        noStroke();
        fill(...PALETTE.eyeGreen,190);
        beginShape();
        for(let a=0;a<TWO_PI;a+=0.06){
          let ex = cos(a)*19, ey = sin(a)*eyeH/2.4*eyeOpen;
          vertex(ex,ey);
        }
        endShape(CLOSE);
        fill(20,70,20,170);
        beginShape();
        vertex(-8,-eyeH/2.7); vertex(0,-eyeH/1.5); vertex(8,-eyeH/2.7);
        vertex(12,eyeH/2.7); vertex(0,eyeH/1.09); vertex(-12,eyeH/2.7);
        endShape(CLOSE);
        pop();
      }
      pop();

      // PÀJARO (animació simple color/posició)
      push();
      let birdY = -eyeH*1.6 + map(inten,0,1,-8,10);
      fill(...birdColor, 165);
      stroke(140,50,90,70);
      strokeWeight(2+6*inten);
      beginShape();
        vertex(-30, birdY-12);
        bezierVertex(-1, birdY-33, 38, birdY-19, 40, birdY+24);
        vertex(15, birdY+23);
        bezierVertex(2, birdY+37, -18, birdY+21, -30, birdY-12);
      endShape(CLOSE);
      // cap i bec
      fill(...birdColor, 220);
      ellipse(37, birdY+8, 23,19);
      fill(220,180,90,180);
      triangle(48, birdY+8, 63, birdY+2, 48, birdY+12);
      strokeWeight(2);
      fill(40,0,0,220);
      ellipse(42, birdY+7, 4,4);
      pop();

      // NAS (vermell, estilitzat)
      fill(...PALETTE.nose);
      stroke(200,60,70,90);
      strokeWeight(6);
      beginShape();
        vertex(-18, noseY);
        bezierVertex(-6, noseY+noseH/2, 6, noseY+noseH/2, 18, noseY);
        vertex(0, noseY-8);
      endShape(CLOSE);

      // BOCA (varia per expressió)
      noFill();
      stroke(130,50,60, 230);
      strokeWeight(8);
      beginShape();
        vertex(-45, noseY+30);
        if (mouthSmile > 0.05) {
          bezierVertex(-18, noseY+60, 18, noseY+60, 45, noseY+30);
          bezierVertex(10, noseY+75, -10, noseY+75, -45, noseY+30);
        } else if (mouthFrown > 0.05) {
          bezierVertex(-18, noseY+85, 18, noseY+85, 45, noseY+30);
          bezierVertex(0, noseY+135, 0, noseY+135, -45, noseY+30);
        } else if (mouthWide > 0.05) {
          bezierVertex(-18, noseY+88, 18, noseY+88, 45, noseY+30);
          bezierVertex(20, noseY+110, -20, noseY+110, -45, noseY+30);
        } else {
          bezierVertex(-18, noseY+75, 18, noseY+75, 45, noseY+30);
        }
      endShape();

      // BIGOTIS ("whiskers") animats
      stroke(...PALETTE.whisker, 100);
      strokeWeight(5);
      for(let i=-1;i<=1;i+=2) {
        let wx = i*70, wy = noseY+38;
        line(wx, wy, wx + i*150*whiskerSpread, wy-16);
        line(wx, wy+18, wx + i*158*whiskerSpread, wy+18+14);
        line(wx, wy-10, wx + i*138*whiskerSpread, wy-36);
      }
    }

    // HUD i previsualització vídeo
    function drawHUD() {
      const traduccions = {
        happy: "😃 Feliç",
        sad: "😢 Trist",
        angry: "😡 Enfadat",
        surprised: "😲 Sorprès",
        disgusted: "🤢 Fastiguejat",
        neutral: "😐 Neutral",
        fearful: "😨 Espantat"
      };
      const emoticon = traduccions[currentExpression.dominant] || "😐 Neutral";
      noStroke();
      fill(50, 150, 255);
      textSize(map(width, 500, 1200, 16, 24));
      textAlign(CENTER, TOP);
      text(`${emoticon} (${floor(smoothIntensity * 100)}%)`, width / 2, 20);
    }

    function drawVideoPreview() {
      const previewSize = min(width, height) * 0.15;
      image(
        video,
        width - previewSize - 10,
        height - previewSize - 10,
        previewSize,
        previewSize
      );
    }

    navigator.mediaDevices.getUserMedia({ video: true })
      .catch(err => {
        document.getElementById('loading-screen').innerHTML = `
          <p style="color: red; text-align: center">
            Error de càmera!<br>
            Permet l'accés a la càmera i actualitza.
          </p>
        `;
      });
  </script>
</body>
</html>
