<!DOCTYPE html>
<html lang="ca">
<!--
  L'atribut "lang" especifica que el contingut est√† en catal√†
  Aquesta obra geom√®trica s'animar√† per mostrar expressions (somriure, tristesa, etc.)
  segons el model de codi facial interactiu.
  Imatge refer√®ncia: ![image1](image1)
-->
<head>
  <meta charset="UTF-8">
  <!-- Defineix la codificaci√≥ de car√†cters com UTF-8, assegurant la correcta visualitzaci√≥ de tots els s√≠mbols -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Defineix el viewport perqu√® la p√†gina s'adapti a dispositius m√≤bils -->
  <title>Art Facial Responsiu - Transicions Suaus i Fons Din√†mic</title>
  <!-- Estableix el t√≠tol de la p√†gina, que apareixer√† a la pestanya del navegador -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.3/p5.js"></script>
  <!-- Carrega la biblioteca p5.js per al dibuix interactiu i la gesti√≥ del canvas -->
  <script src="https://cdn.jsdelivr.net/gh/ml5js/Intro-ML-Arts-IMA@ml5-build-10-7-19/ml5_build/ml5.min.js"></script>
  <!-- Aquest script carrega ml5.js en una versi√≥ compilada, utilitzada per la detecci√≥ facial -->
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background: #222; }
    /* Fons fosc per ressaltar la pe√ßa geom√®trica */
    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: Arial, sans-serif;
      z-index: 1000;
    }
    .loader {
      width: 40px;
      height: 40px;
      border: 5px solid #3498db;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #loading-screen p {
      margin-top: 15px;
      font-size: 1.1em;
      color: #333;
    }
  </style>
</head>
<body>
<!--
  // Aquesta p√†gina mostra una animaci√≥ d'una obra geom√®trica (imatge 1)
  // on la composici√≥ de triangles es transforma per expressar emocions:
  // happy, sad, angry, surprised, disgusted i neutral.
  // Els canvis s√≥n subtils, art√≠stics i inspirats en la pintura original.
  // Imatge: ![image1](image1)
-->
  <div id="loading-screen">
    <!-- Aquest element cont√© el cercle giratori -->
    <div class="loader"></div>
    <!-- I un missatge per informar a l'usuari que es carreguen els models -->
    <p>Carregant models...</p>
  </div>
  <script>
    // VARIABLES GLOBALES
    let faceapi, detections = [], video;
    // "faceapi" ser√† l'objecte que ens gestionar√† la detecci√≥ facial.
    // "detections" √©s una matriu (array) que emmagatzemar√† les deteccions facials.
    // "video" guardar√† el flux de v√≠deo capturat des de la c√†mera.

    let modelsReady = false;
    // Variable booleana que indicar√† si els models han estat carregats correctament (comen√ßa en false).
    let currentExpression = { dominant: 'neutral', intensity: 0 };
    // Objecte que emmagatzema l'expressi√≥ facial actual.
    let smoothIntensity = 0;
    // Aix√≤ permet interpolar suaument entre l'estat anterior i el nou.

    // VARIABLES PER AL FONS ‚Äì GRADIENT DIN√ÄMIC
    let currentGradientStart, currentGradientEnd;
    let targetGradientStart, targetGradientEnd;

    // Variables per l'animaci√≥ geom√®trica
    let expressionList = ["neutral", "happy", "sad", "angry", "surprised", "disgusted"];
    let geomIntensity = 0.8; // Intensitat per a la geometria (0 a 1)
    let geomExpr = "neutral";

    // FUNCI√ì PER OBTINDRE ELS COLORS DEL GRADIENT
    function getGradientForEmotion(emotion) {
      switch (emotion) {
        case 'happy':
          return { start: color(255, 223, 186), end: color(255, 183, 77) };
        case 'sad':
          return { start: color(173, 216, 230), end: color(100, 149, 237) };
        case 'angry':
          return { start: color(255, 160, 122), end: color(255, 69, 0) };
        case 'disgusted':
          return { start: color(144, 238, 144), end: color(34, 139, 34) };
        case 'surprised':
          return { start: color(216, 191, 216), end: color(147, 112, 219) };
        default:
          return { start: color(240, 240, 240), end: color(200, 200, 200) };
      }
    }

    // FUNCI√ì PER DIBUIXAR UN GRADIENT VERTICAL
    function setGradient(x, y, w, h, c1, c2, axis = 'y') {
      noFill();
      if (axis === 'y') {
        for (let i = y; i <= y + h; i++) {
          let inter = map(i, y, y + h, 0, 1);
          let c = lerpColor(c1, c2, inter);
          stroke(c);
          line(x, i, x + w, i);
        }
      } else if (axis === 'x') {
        for (let i = x; i <= x + w; i++) {
          let inter = map(i, x, x + w, 0, 1);
          let c = lerpColor(c1, c2, inter);
          stroke(c);
          line(i, y, i, y + h);
        }
      }
    }

    // FUNCI√ì SETUP (p5.js)
    function setup() {
      createCanvas(windowWidth, windowHeight);
      let neutralGrad = getGradientForEmotion('neutral');
      currentGradientStart = neutralGrad.start;
      currentGradientEnd = neutralGrad.end;

      video = createCapture(VIDEO);
      video.size(320, 240);
      video.hide();
      video.elt.muted = true;
      video.elt.playsinline = true;

      const options = {
        withLandmarks: true,
        withExpressions: true,
        withDescriptors: false
      };

      faceapi = ml5.faceApi(video, options, () => {
        modelsReady = true;
        document.getElementById('loading-screen').style.display = 'none';
        faceapi.detect(gotResults);
      });
    }

    // FUNCI√ì windowResized (p5.js)
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      video.size(max(160, width / 4), max(120, height / 4));
    }

    // FUNCI√ì gotResults - Callback de detecci√≥ facial
    function gotResults(err, results) {
      if (err) {
        console.error(err);
        document.getElementById('loading-screen').innerHTML =
          '<p style="color: red">Error! Comprova la c√†mera i actualitza.</p>';
        return;
      }
      detections = results;
      if (detections.length > 0) updateCurrentExpression();
      faceapi.detect(gotResults);
    }

    // FUNCI√ì updateCurrentExpression
    function updateCurrentExpression() {
      let maxIntensity = 0;
      detections.forEach(face => {
        const expr = face.expressions;
        const dominant = Object.keys(expr).reduce((a, b) => expr[a] > expr[b] ? a : b);
        if (expr[dominant] > maxIntensity) {
          currentExpression = {
            dominant: dominant,
            intensity: expr[dominant]
          };
          maxIntensity = expr[dominant];
        }
      });
      let grad = getGradientForEmotion(currentExpression.dominant);
      targetGradientStart = grad.start;
      targetGradientEnd = grad.end;
      // Actualitza la geometria per mostrar la mateixa expressi√≥
      geomExpr = currentExpression.dominant;
      geomIntensity = currentExpression.intensity;
    }

    function scaleFactor() {
      return Math.min(width, height) / 800;
    }

    // FUNCI√ì draw (p5.js)
    function draw() {
      smoothIntensity = lerp(smoothIntensity, currentExpression.intensity, 0.1);

      if (targetGradientStart && targetGradientEnd) {
        currentGradientStart = lerpColor(currentGradientStart, targetGradientStart, 0.1);
        currentGradientEnd = lerpColor(currentGradientEnd, targetGradientEnd, 0.1);
      }

      setGradient(0, 0, width, height, currentGradientStart, currentGradientEnd, 'y');

      // Dibuixa l'art geom√®tric expressiu al centre del canvas
      push();
      translate(width / 2, height / 2);
      // Dibuixa la pe√ßa geom√®trica animada segons l'expressi√≥ detectada
      drawGeometricFace(geomExpr, geomIntensity);
      pop();

      // Dibuixa la interf√≠cie (HUD) amb informaci√≥ textual (emoticon i percentatge).
      drawHUD();
      // Dibuixa una previsualitzaci√≥ petita del v√≠deo en una cantonada.
      drawVideoPreview();
    }

    /*
      // Dibuixa la pe√ßa geom√®trica amb modificacions subtils segons l'expressi√≥
      // Cada triangle/pol√≠gon pot canviar de color, rotaci√≥, o posici√≥ per simular emoci√≥
      // Inspirat en la imatge refer√®ncia ![image1](image1)
    */
    function drawGeometricFace(expr, inten) {
      // Paleta b√†sica
      let baseColors = {
        dark: color(40, 10, 10),
        red: color(220, 60, 20),
        orange: color(255, 110, 30),
        gray: color(180),
        brown: color(110, 60, 30)
      };
      // Animaci√≥: canvia lleugerament tons segons expressi√≥
      let exp = expr || "neutral";
      if (exp === "happy") {
        baseColors.orange = lerpColor(baseColors.orange, color(255,200,50), inten);
        baseColors.red = lerpColor(baseColors.red, color(255,100,80), inten);
      } else if (exp === "sad") {
        baseColors.orange = lerpColor(baseColors.orange, color(100,150,255), inten);
        baseColors.red = lerpColor(baseColors.red, color(80,110,180), inten);
        baseColors.gray = lerpColor(baseColors.gray, color(220,220,255), inten);
      } else if (exp === "angry") {
        baseColors.red = lerpColor(baseColors.red, color(180,10,10), inten);
        baseColors.dark = lerpColor(baseColors.dark, color(120,0,0), inten);
      } else if (exp === "surprised") {
        baseColors.gray = lerpColor(baseColors.gray, color(255,255,255), inten);
        baseColors.orange = lerpColor(baseColors.orange, color(255,220,160), inten);
      } else if (exp === "disgusted") {
        baseColors.orange = lerpColor(baseColors.orange, color(140,220,130), inten);
        baseColors.red = lerpColor(baseColors.red, color(120,180,90), inten);
      }

      // Dibuixa el quadrat exterior (marge marr√≥)
      fill(baseColors.brown);
      stroke(40);
      strokeWeight(3);
      rectMode(CENTER);
      rect(0, 0, 240, 240, 6);

      // Dibuixa la graella interna de triangles (4x4)
      let s = 48; // mida d'un quadrat de la graella
      let o = -3 * s/2; // offset per centrar
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          push();
          let cx = o + col*s + s/2;
          let cy = o + row*s + s/2;
          translate(cx, cy);

          // Happy: boca (fila 2)
          if (exp === "happy" && row === 2 && (col === 1 || col === 2)) {
            fill(baseColors.red);
            rotate(-PI/12);
            triangle(-s/2, s/2, s/2, s/2, 0, -s/2 - inten*8);
          }
          // Sad: boca (fila 2)
          else if (exp === "sad" && row === 2 && (col === 1 || col === 2)) {
            fill(baseColors.gray);
            rotate(PI/12);
            triangle(-s/2, -s/2, s/2, -s/2, 0, s/2 + inten*8);
          }
          // Angry: central (punxes)
          else if (exp === "angry" && row === 1 && (col === 1 || col === 2)) {
            fill(baseColors.red);
            triangle(-s/2, s/2, s/2, s/2, 0, -s/2 - inten*15);
          }
          // Surprised: boca molt oberta (fila 2)
          else if (exp === "surprised" && row === 2 && (col === 1 || col === 2)) {
            fill(baseColors.gray);
            ellipse(0, 0, s*0.9 + inten*25, s*0.9 + inten*25);
          }
          // Disgusted: boca distorsionada
          else if (exp === "disgusted" && row === 2 && col === 2) {
            fill(baseColors.orange);
            beginShape();
            vertex(-s/2, s/2);
            vertex(s/2, s/2);
            vertex(0, -s/2 + inten*10);
            vertex(-s/3, 0);
            endShape(CLOSE);
          }
          // Ulls expressius
          else if ((row === 1 && (col === 1 || col === 2))) {
            if (exp === "happy") {
              fill(baseColors.orange);
              arc(0, -s/8, s*0.7, s*0.5, 0, PI, OPEN);
            } else if (exp === "sad") {
              fill(baseColors.gray);
              arc(0, 0, s*0.7, s*0.5, PI, 0, OPEN);
            } else if (exp === "angry") {
              fill(baseColors.red);
              arc(0, -s/6, s*0.7, s*0.4, PI*1.2, PI*1.9, OPEN);
            } else if (exp === "surprised") {
              fill(baseColors.gray);
              ellipse(0, 0, s*0.6 + inten*8, s*0.6 + inten*8);
            } else if (exp === "disgusted") {
              fill(baseColors.orange);
              beginShape();
              vertex(-s/4, s/8);
              vertex(s/4, s/8);
              vertex(0, -s/4 - inten*8);
              endShape(CLOSE);
            } else {
              fill(baseColors.orange);
              triangle(-s/2, -s/2, s/2, -s/2, 0, s/2);
            }
          }
          // Altres: fons geom√®tric
          else {
            if ((row+col)%2 == 0)
              fill(baseColors.orange);
            else
              fill(baseColors.dark);
            triangle(-s/2, -s/2, s/2, -s/2, 0, s/2);
          }
          pop();
        }
      }
      // Somriure addicional per happy
      if (exp === "happy") {
        noFill();
        stroke(255, 180, 60, 180);
        strokeWeight(7);
        arc(0, 52, 80+inten*20, 30+inten*8, 0.15*PI, 0.85*PI);
      }
      // Boca trista addicional per sad
      if (exp === "sad") {
        noFill();
        stroke(80, 130, 255, 180);
        strokeWeight(6);
        arc(0, 58, 65+inten*18, 26+inten*8, 1.1*PI, 1.9*PI);
      }
    }

    // FUNCI√ì drawHUD
    function drawHUD() {
      const traduccions = {
        happy: "üòÉ Feli√ß",
        sad: "üò¢ Trist",
        angry: "üò° Enfadat",
        surprised: "üò≤ Sorpr√®s",
        disgusted: "ü§¢ Fastiguejat",
        neutral: "üòê Neutral",
        fearful: "üò® Espantat"
      };
      const emoticon = traduccions[currentExpression.dominant] || "üòê Neutral";
      noStroke();
      fill(50, 150, 255);
      textSize(map(width, 500, 1200, 16, 24));
      textAlign(CENTER, TOP);
      text(`${emoticon} (${floor(smoothIntensity * 100)}%)`, width / 2, 20);
    }

    // FUNCI√ì drawVideoPreview
    function drawVideoPreview() {
      const previewSize = min(width, height) * 0.15;
      image(
        video,
        width - previewSize - 10,
        height - previewSize - 10,
        previewSize,
        previewSize
      );
    }

    // GESTI√ì D'ERRORS AMB LA C√ÄMERA
    navigator.mediaDevices.getUserMedia({ video: true })
      .catch(err => {
        document.getElementById('loading-screen').innerHTML = `
          <p style="color: red; text-align: center">
            Error de c√†mera!<br>
            Permet l'acc√©s a la c√†mera i actualitza.
          </p>
        `;
      });
  </script>
</body>
</html>
